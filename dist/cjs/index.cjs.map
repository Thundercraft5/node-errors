{
  "version": 3,
  "sources": ["src/index.ts", "src/nativeMessages/toRepresentation.ts", "src/nativeMessages/index.ts", "src/utils/omit.ts", "src/makeErrors.ts", "src/nativeErrors.ts", "src/utils/formatWordList.ts", "src/utils/formatErrorMessage.ts", "src/makeCodedError.ts", "src/symbols.ts", "src/utils/isCodedError.ts", "src/utils/isCodedErrorClass.ts"],
  "sourcesContent": ["export { default as makeCodedError } from \"./makeCodedError\";\r\nexport { default, default as makeErrors } from \"./makeErrors\";\r\nexport * from \"./nativeErrors\";\r\nexport { default as messages } from \"./nativeMessages\";\r\nexport * from \"./symbols\";\r\nexport * from \"./types\";\r\nexport { default as isCodedError } from \"./utils/isCodedError\";\r\nexport { default as isCodedErrorClass } from \"./utils/isCodedErrorClass\";", "const toString = (v: any) => Object.prototype.toString.call(v);\r\n\r\n/*\r\n * type GlobalThis$1 = Omit<GlobalThis, \"__dirname\" | \"__filename\" | \"exports\" | \"globalThis\" | \"Object\">;\r\n * type GlobalConstructors = PickByValue<GlobalThis$1, Constructor>;\r\n * type GlobalConstructorTypes = {\r\n * \t[K in keyof GlobalConstructors]: ConstructorReturnType<GlobalConstructors[K]>;\r\n * };\r\n */\r\n\r\n/*\r\n * type ToRepresentation<T> =\r\n * \tT extends (ExtractExact<GlobalConstructorTypes[keyof GlobalConstructorTypes], T>)\r\n * \t\t? `${ TypeOf<T> } [object ${ KeysByValue<GlobalConstructorTypes, T> }]`\r\n * \t: T extends any[]\r\n * \t\t? `${ TypeOf<T> } [object Array]`\r\n * \t: T extends boolean | number\r\n * \t\t? `${ TypeOf<T> } ${ `${ T }` }`\r\n * \t: T extends undefined\r\n * \t\t? \"undefined\"\r\n * \t: T extends string\r\n * \t\t? `${ TypeOf<T> } \"${ T }\"`\r\n * \t: T extends symbol\r\n * \t\t? `${ TypeOf<T> } Symbol(${ string | \"\" })`\r\n * \t: T extends bigint\r\n * \t\t? `${ TypeOf<T> } ${ T }n`\r\n * \t: `${ TypeOf<T> } ${ T extends null ? \"null\" : `#<${ string }>` }`;\r\n */\r\n\r\n// \ttype Any = bigint | boolean | number | object | string | symbol | null | undefined;\r\nexport default function toRepresentation(object: any, includeType: boolean = false): string {\r\n\tlet valueRepresentation = \"\";\r\n\r\n\tswitch (typeof object) {\r\n\t\tcase \"string\": {\r\n\t\t\tvalueRepresentation = `\"${ object.slice(1, 100) } ${ object.length >= 100 ? \"<...>\" : \"\" }\"`;\r\n\t\t} break;\r\n\t\tcase \"bigint\": valueRepresentation = `${ String(object) }n`; break;\r\n\t\tcase \"symbol\":\r\n\t\tcase \"boolean\":\r\n\t\tcase \"undefined\":\r\n\t\tcase \"function\":\r\n\t\tcase \"number\": valueRepresentation = String(object); break;\r\n\t\tcase \"object\": {\r\n\t\t\tif (object == null) valueRepresentation = String(object);\r\n\t\t\telse {\r\n\t\t\t\tconst\r\n\t\t\t\t\tconstructorName = Reflect.getPrototypeOf(object)?.constructor.name,\r\n\t\t\t\t\ttoStringName = toString(object).slice(8, -1);\r\n\r\n\t\t\t\tvalueRepresentation = toStringName in globalThis && toStringName !== \"Object\"\r\n\t\t\t\t\t? toString(object)\r\n\t\t\t\t\t: `#<${ constructorName }>`;\r\n\t\t\t}\r\n\r\n\t\t\tbreak;\r\n\t\t}\r\n\t\tdefault: throw new TypeError();\r\n\t}\r\n\r\n\treturn `${ includeType && object !== \"undefined\" ? `${ typeof object } ` : \"\" }${ valueRepresentation }`;\r\n}", "import toRepresentation from \"./toRepresentation\";\r\nimport type { ErrorClass } from \"..\";\r\n\r\nconst messages = {\r\n\t// Internal error messages\r\n\tERROR_CLASS_ALREADY_EXTENDED: (Class: ErrorClass) => `Error class \"${ Class.name }\" is already a coded error class.`,\r\n\tINVALID_MESSAGE_CODE: (code = \"\", validCodes = \"\") => `Error code \"${ code }\" was not found in the provided messages registry.\\nList of valid codes: ${ validCodes }`,\r\n\tMESSAGE_CODE_MISSING_FORMATS: (code = \"\", required = 0, received = 0) => `Message code \"${ code }\" expects at least ${ required } format arguments, got ${ received } instead`,\r\n\r\n\t// Built-in error messages\r\n\tMETHOD_NOT_IMPLEMENTED: (Class: Function, name = \"\") => `Method ${ Class.name }#${ name }() is not implemented.`,\r\n\tREADONLY_PROPERTY_SET: (object: any, key: number | string | symbol) => `Cannot assign to read only property '${ String(key) }' of object '${ toRepresentation(object, false) }'`,\r\n\tREADONLY_PROPERTY_DELETE: (object: any, key: number | string | symbol) => `Cannot delete read only property '${ String(key) }' of object '${ toRepresentation(object, false) }'`,\r\n\tOBJECT_NOT_EXTENSIBLE: (object: any, key: number | string | symbol) => `Cannot add property '${ String(key) }', object '${ toRepresentation(object) } is not extensible'`,\r\n\tCANNOT_ADD_OBJECT_PROPERTY: (value: any, key: number | string | symbol) => `Cannot add property '${ String(key) }' on ${ typeof value } '${ toRepresentation(value) }'`,\r\n\tVALUE_OUT_OF_RANGE: (value: bigint | number, min: bigint | number, max: bigint | number) => `Value \"${ value } is out of range. Values must be in the range of \"${ min }\" to \"${ max }\".`,\r\n};\r\n\r\nexport default messages;", "function entries<T extends object>(object: T) {\r\n\treturn Object.entries(object) as [keyof T, T[keyof T]][];\r\n}\r\n\r\nexport default function omit<T extends object, U extends [...(keyof T)[]]>(object: T, ...keys: [...U]) {\r\n\tconst newObject = {} as Omit<T, U[number]>,\r\n\t objectEntries = entries(object)\r\n\t \t.filter(([k]) => !keys.includes(k)) as [Exclude<keyof T, U[number]>, T[Exclude<keyof T, U[number]>]][];\r\n\r\n\tfor (const [k, v] of objectEntries)\r\n\t\tnewObject[k] = v;\r\n\r\n\treturn newObject;\r\n}", "import makeCodedError from \"./makeCodedError\";\r\nimport nativeMessages from \"./nativeMessages\";\r\nimport type { SymbolCode, SymbolCodedError, SymbolCodedErrorClass, SymbolRawMessage } from \"./symbols\";\r\nimport { ErrorClass, MessageMap, ErrorsDescriptor, Message, ConstructorReturnType } from \"./types\";\r\nimport omit from \"./utils/omit\";\r\n\r\nexport type ErrorMap<M extends MessageDescriptor<M, E>, E extends ErrorsDescriptor> = {\r\n\t[K in keyof E]?: ReturnType<typeof makeCodedError<M[K] & Omit<M, keyof E>, E[K]>>;\r\n};\r\n\r\nexport type MessageDescriptor<M extends MessageMap, E extends ErrorsDescriptor> = {\r\n\t[K in Exclude<keyof M, keyof E>]: Message\r\n} & {\r\n\t[K in keyof E]?: MessageMap\r\n}\r\n\r\nexport default function makeErrors<\r\n\tM extends MessageDescriptor<M, E>,\r\n\tE extends ErrorsDescriptor,\r\n>(messages: M, errors: E, includeNativeCodes: true): Required<ErrorMap<M & typeof nativeMessages, E>>;\r\n\r\nexport default function makeErrors<\r\n\tM extends MessageDescriptor<M, E>,\r\n\tE extends ErrorsDescriptor,\r\n>(messages: M, errors: E): Required<ErrorMap<M, E>>;\r\n\r\nexport default function makeErrors<\r\n\tM extends MessageDescriptor<M, E>,\r\n\tE extends ErrorsDescriptor,\r\n>(messages: M = {} as M, errors: E = {} as E, includeNativeCodes = true) {\r\n\tif (includeNativeCodes) messages = { ...messages, ...nativeMessages };\r\n\r\n\tconst ret: ErrorMap<M | (M & typeof nativeMessages), E> = {},\r\n\t\tentries = Object.entries(errors) as [keyof E, E[keyof E]][];\r\n\r\n\tfor (const [k, error] of entries) {\r\n\t\tret[k] = makeCodedError(Object.assign(messages[k] || {}, omit(messages, ...(Object.keys(errors) as (keyof E)[]))), error);\r\n\t}\r\n\r\n\treturn ret as Required<ErrorMap<M | (M & typeof nativeMessages), E>>;\r\n}", "import makeErrors from \"./makeErrors\";\r\nimport messages from \"./nativeMessages\";\r\nimport type { SymbolCode, SymbolCodedError, SymbolCodedErrorClass, SymbolRawMessage } from \"./symbols\";\r\n\r\nexport const\r\n\t{\r\n\t\tTypeError,\r\n\t\tRangeError,\r\n\t\tReferenceError,\r\n\t\tError,\r\n\t} = makeErrors(messages, {\r\n\t\tTypeError: globalThis.TypeError,\r\n\t\tRangeError: globalThis.RangeError,\r\n\t\tReferenceError: globalThis.ReferenceError,\r\n\t\tError: globalThis.Error,\r\n\t});", "export default function formatWordList(list: string[], and = false) {\r\n\tconst last = list.pop(),\r\n\t\tlastWord = and ? \"and\" : \"or\";\r\n\r\n\tif (list.length > 1) {\r\n\t\tconst commaSeparated = list.map((s, i) => `${ i % 5 === 0 && i ? \"\\n\" : \"\" }\"${ s }\"`);\r\n\r\n\t\treturn `${ commaSeparated.join(\", \") }, ${ lastWord } \"${ last }\"`;\r\n\t} else return `${ list.length === 1 ? `\"${ list[0] }\" ${ lastWord } ` : \"\" }\"${ last }\"`;\r\n}", "import { RangeError, ReferenceError } from \"../nativeErrors\";\nimport type { FormattableMessageParams,MessageFormatter, MessageKeys, MessageMap } from \"../types\";\nimport { MessageDescriptor } from \"../types\";\nimport formatWordList from \"./formatWordList\";\n\r\nexport default function formatErrorMessage<\r\n\tM extends MessageMap,\r\n\tCode extends MessageKeys<M>,\r\n>(messages: M, code: Code, ...formats: FormattableMessageParams<M, Code>) {\r\n\tif (!(code in messages)) throw new ReferenceError(\"INVALID_MESSAGE_CODE\", code, formatWordList(Object.keys(messages)));\r\n\r\n\tif (typeof messages[code] === \"function\" && messages[code]!.length > formats.length) throw new RangeError(\"MESSAGE_CODE_MISSING_FORMATS\", code, messages[code]!.length, formats.length);\r\n\r\n\tconst message = typeof messages[code] === \"function\"\r\n\r\n\t\t? (messages[code] as MessageFormatter)(...formats)\r\n\t\t: messages[code];\r\n\r\n\treturn message as string;\r\n}", "/* eslint-disable @typescript-eslint/member-ordering */\r\nimport { TypeError } from \"./nativeErrors\";\r\nimport { SymbolCode, SymbolCodedError, SymbolCodedErrorClass, SymbolRawMessage } from \"./symbols\";\r\n\r\nimport { indent } from \"./utils\";\r\nimport formatErrorMessage from \"./utils/formatErrorMessage\";\r\nimport type { ConstructorReturnType , FormattableMessageParams, MessageDescriptor, MessageKeys, MessageMap } from \"./types\";\r\n\r\ntype OmitCallSignature<T> =\r\n\tT extends new (...args: infer R) => infer S ? new (...args: R) => S & { [K in keyof T]: T[K] } : { [K in keyof T]: T[K] };\r\n\r\ntype OmitConstructorSignature<T> =\r\n\tT extends (...args: infer R) => infer S ? (...args: R) => S & { [K in keyof T]: T[K] } : { [K in keyof T]: T[K] };\r\ntype Map<T> = { [K in keyof T]: T[K] };\r\ntype LastOfTuple<T extends any[]> = T extends [...infer Rest, infer Last] ? Last : never;\r\ntype SliceLast<T extends any[]> = T extends [...infer Rest, infer Discard] ? Rest : never;\r\ntype ErrorOptions = Omit<globalThis.ErrorOptions, \"cause\"> & { cause?: Error };\r\n\r\nexport default function makeCodedError<\r\n\tM extends MessageMap,\r\n\tT extends abstract new (...args: any[]) => Error,\r\n>(messages: M, Base: T) {\r\n\t// if (SymbolCodedErrorClass in Base) throw new TypeError(\"ERROR_CLASS_ALREADY_EXTENDED\", Base);\r\n\tif (\"$$<Symbol>isCodedError\" in Base) throw new TypeError(\"ERROR_CLASS_ALREADY_EXTENDED\", Base);\r\n\r\n\r\n\t// @ts-expect-error\r\n\tclass $0<Code extends Upppercase<MessageKeys<M>>, Options extends ErrorOptions = {}> extends Base {\r\n\t\t// static get [SymbolCodedErrorClass]() { return true; }\r\n\t\tstatic readonly [\"$$<Symbol>isCodedErrorClass\"] = true;\r\n\t\tstatic [Symbol.hasInstance](instance: any) {\r\n\t\t\tconst constructor = instance[Symbol.species] || instance.constructor;\r\n\r\n\t\t\treturn instance instanceof Base || constructor === this;\r\n\t\t}\r\n\r\n\t\tstatic {\r\n\t\t\tObject.defineProperty(this, \"name\", { value: Base.name });\r\n\t\t}\r\n\r\n\t\tstatic #lookupGetter<I extends $0<string, ErrorOptions>, K extends keyof I>(instance: I, key: K) {\r\n\t\t\treturn Object.getOwnPropertyDescriptors(instance)[key].get as {\r\n\t\t\t\t[P in keyof I]: TypedPropertyDescriptor<I[P]>\r\n\t\t\t}[K][\"get\"];\r\n\t\t}\r\n\r\n\t\t#message = \"\";\r\n\t\t#stackTrace = \"\";\r\n\t\t#cause?: unknown extends Options[\"cause\"] ? Error : Options[\"cause\"];\r\n\t\t/*\r\n\t\t * readonly [SymbolCodedError]: true;\r\n\t\t * readonly [SymbolCode]: string;\r\n\t\t * readonly [SymbolRawMessage]: string;\r\n\t\t */\r\n\t\treadonly [\"$$<Symbol>isCodedError\"]: true;\r\n\t\treadonly [\"code\"]: Code;\r\n\t\treadonly [\"rawMessage\"]: string;\r\n\r\n\t\tconstructor(code: Code, ...formats: [...FormattableMessageParams<M, Code>, Options]);\r\n\t\tconstructor(code: Code, ...formats: [...FormattableMessageParams<M, Code>]);\r\n\t\tconstructor(code: Code, ...args: [...FormattableMessageParams<M, Code>, Options] | [...FormattableMessageParams<M, Code>]) {\r\n\t\t\tconst formats = (Object.hasOwn((args.at(-1) as Options | undefined) ?? {}, \"cause\")\r\n\t\t\t\t\t? args.slice(0, -1)\r\n\t\t\t\t\t: args) as FormattableMessageParams<M, Code>,\r\n\t\t\t\toptions = (Object.hasOwn((args.at(-1) as Options | undefined) ?? {}, \"cause\")\r\n\t\t\t\t\t? args.at(-1)\r\n\t\t\t\t\t: {}) as Options;\r\n\r\n\t\t\tsuper();\r\n\r\n\t\t\t// @ts-expect-error\r\n\t\t\tdelete this[\"$$<Symbol>isCodedError\"];\r\n\r\n\t\t\tthis.#message = formatErrorMessage(messages, code, ...formats);\r\n\t\t\tthis.#stackTrace = this.stack!.split(\"\\n\").slice(1).join(\"\\n\");\r\n\t\t\tthis.#cause = options.cause!;\r\n\r\n\t\t\tif (typeof messages[code] !== \"string\")\r\n\t\t\t\t// this[SymbolRawMessage] = messages[code]?.toString()!;\r\n\t\t\t\tthis.rawMessage = messages[code]?.toString()!;\r\n\r\n\t\t\tthis.code = code.toLocaleUpperCase() as Code;\r\n\t\t\t// Object.defineProperty(this, SymbolCodedError, { value: true });\r\n\t\t\tObject.defineProperty(this, \"$$<Symbol>isCodedError\", { value: true });\r\n\r\n\t\t\tObject.defineProperties(this, {\r\n\t\t\t\tname: {\r\n\t\t\t\t\tget: () => this.#name,\r\n\t\t\t\t},\r\n\t\t\t\tstack: {\r\n\t\t\t\t\tget: () => this.#stack,\r\n\t\t\t\t},\r\n\t\t\t});\r\n\r\n\r\n\t\t\t// use defineProperty() to ensure `this.cause` does not appear as undefined in runtime\r\n\t\t\tif (Object.hasOwn(options, \"cause\")) Object.defineProperty(this, \"cause\", {\r\n\t\t\t\tvalue: options.cause,\r\n\t\t\t\tenumerable: false,\r\n\t\t\t}); else delete this.cause;\r\n\t\t}\r\n\r\n\t\tget #name() {\r\n\t\t\treturn `${ Base.name }${ this.code ? ` [${ this.code }]` : \"\" }`;\r\n\t\t}\r\n\r\n\t\tget #stack() {\r\n\t\t\treturn `${ this.name }: ${ this.message }\\n${ this.#stackTrace }`;\r\n\t\t}\r\n\r\n\t\tget message() {\r\n\t\t\treturn this.#message;\r\n\t\t}\r\n\r\n\t\tget name() {\r\n\t\t\treturn this.#name;\r\n\t\t}\r\n\r\n\t\tget [Symbol.species]() { return Base; }\r\n\r\n\t\tget [Symbol.toStringTag]() {\r\n\t\t\treturn Base.name;\r\n\t\t}\r\n\t}\r\n\r\n\treturn $0 as any as (Map<typeof $0>\r\n\t& Omit<typeof Base, \"prototype\">\r\n\t& (ConstructorReturnType<typeof Base> & {\r\n\t\tnew <Code extends MessageKeys<M>, Options extends ErrorOptions = {}>(code: Code, ...formats: [...formats: FormattableMessageParams<M, Code>, options: Options]): $0<Code, Options>;\r\n\t\tnew <Code extends MessageKeys<M>, Options extends ErrorOptions = {}>(code: Code, ...formats: [...FormattableMessageParams<M, Code>]): $0<Code, Options>;\r\n\t}));\r\n}", "export const\r\n\tSymbolCodedErrorClass = Symbol(\"codedErrorClass\"),\r\n\tSymbolCodedError = Symbol(\"codedError\"),\r\n\tSymbolCode = Symbol(\"code\"),\r\n\tSymbolRawMessage = Symbol(\"rawMessage\");", "import { SymbolCode } from \"../symbols\";\r\nimport type { CodedError} from \"../types\";\r\nimport { ErrorClass, MessageMap } from \"../types\";\r\n\r\nexport default function isCodedError(errorObject: any): errorObject is CodedError {\r\n\t// return errorObject?.[SymbolCode];\r\n\ttry {\r\n\t\treturn errorObject?.[\"$$<Symbol>isCodedError\"];\r\n\t} catch {\r\n\t\treturn false;\r\n\t}\r\n}\r\n\r\nlet o: any;", "import { SymbolCodedErrorClass } from \"../symbols\";\r\nimport type { CodedError } from \"../types\";\r\n\r\nexport default function isCodedErrorClass(ErrorClass: any): ErrorClass is CodedError {\r\n\t// return SymbolCodedErrorClass in ErrorClass;\r\n\ttry {\r\n\t\treturn ErrorClass?.[\"$$<Symbol>isCodedErrorClass\"];\r\n\t} catch {\r\n\t\treturn false;\r\n\t}\r\n}"],
  "mappings": "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",
  "names": ["Error", "TypeError", "messages", "entries", "TypeError", "Error", "messages", "messages", "TypeError"]
}
