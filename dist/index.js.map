{
  "version": 3,
  "sources": ["../src/nativeMessages.ts", "../src/utils/omit.ts", "../src/makeErrors.ts", "../src/nativeErrors.ts", "../src/utils/formatWordList.ts", "../src/utils/formatErrorMessage.ts", "../src/makeCodedError.ts", "../src/symbols.ts", "../src/utils/isCodedError.ts", "../src/utils/isCodedErrorClass.ts"],
  "sourcesContent": ["import type { ErrorClass } from \"./types\";\r\n\r\nconst messages = {\r\n\tERROR_CLASS_ALREADY_EXTENDED: (Class: ErrorClass) => `Error class \"${ Class.name }\" is already a coded error class.`,\r\n\tINVALID_MESSAGE_CODE: (code = \"\", validCodes = \"\") => `Error code \"${ code }\" was not found in the provided messages registry.\\nList of valid codes: ${ validCodes }`,\r\n\tMESSAGE_CODE_MISSING_FORMATS: (code = \"\", required = 0, received = 0) => `Message code \"${ code }\" expects at least ${ required } format arguments, got ${ received } instead`,\r\n\tMETHOD_NOT_IMPLEMENTED: (Class: Function, name = \"\") => `Method ${ Class.name }#${ name }() is not implemented.`,\r\n};\r\n\r\nexport default messages;", "function entries<T extends object>(object: T) {\r\n\treturn Object.entries(object) as [keyof T, T[keyof T]][];\r\n}\r\n\r\nexport default function omit<T extends object, U extends [...(keyof T)[]]>(object: T, ...keys: [...U]) {\r\n\tconst newObject = {} as Omit<T, U[number]>,\r\n\t objectEntries = entries(object).filter(([k]) => !keys.includes(k)) as [Exclude<keyof T, U[number]>, T[Exclude<keyof T, U[number]>]][];\r\n\r\n\tfor (const [k, v] of objectEntries)\r\n\t\tnewObject[k] = v;\r\n\r\n\treturn newObject;\r\n}", "import makeCodedError from \"./makeCodedError\";\r\nimport nativeMessages from \"./nativeMessages\";\r\nimport type { SymbolCode, SymbolCodedError, SymbolCodedErrorClass, SymbolRawMessage } from \"./symbols\";\r\nimport { ErrorClass, MessageMap, ErrorsDescriptor, Message, ConstructorReturnType } from \"./types\";\r\nimport omit from \"./utils/omit\";\r\n\r\nexport type ErrorMap<M extends MessageDescriptor<M, E>, E extends ErrorsDescriptor> = {\r\n\t[K in keyof E]?: ReturnType<typeof makeCodedError<M[K] & Omit<M, keyof E>, E[K]>>;\r\n};\r\n\r\nexport type MessageDescriptor<M extends MessageMap, E extends ErrorsDescriptor> = {\r\n\t[K in Exclude<keyof M, keyof E>]: Message\r\n} & {\r\n\t[K in keyof E]?: MessageMap\r\n}\r\n\r\nexport default function makeErrors<\r\n\tM extends MessageDescriptor<M, E>,\r\n\tE extends ErrorsDescriptor,\r\n>(messages: M, errors: E, includeNativeCodes: true): Required<ErrorMap<M & typeof nativeMessages, E>>;\r\n\r\nexport default function makeErrors<\r\n\tM extends MessageDescriptor<M, E>,\r\n\tE extends ErrorsDescriptor,\r\n>(messages: M, errors: E): Required<ErrorMap<M, E>>;\r\n\r\nexport default function makeErrors<\r\n\tM extends MessageDescriptor<M, E>,\r\n\tE extends ErrorsDescriptor,\r\n>(messages: M, errors: E, includeNativeCodes = true) {\r\n\tif (includeNativeCodes) messages = { ...messages, ...nativeMessages };\r\n\r\n\tconst ret: ErrorMap<M | (M & typeof nativeMessages), E> = {},\r\n\t\tentries = Object.entries(errors) as [keyof E, E[keyof E]][];\r\n\r\n\tfor (const [k, error] of entries) {\r\n\t\tret[k] = makeCodedError(Object.assign(messages[k] || {}, omit(messages, ...(Object.keys(errors) as (keyof E)[]))), error);\r\n\t}\r\n\r\n\treturn ret as Required<ErrorMap<M | (M & typeof nativeMessages), E>>;\r\n}", "import makeErrors from \"./makeErrors\";\r\nimport messages from \"./nativeMessages\";\r\n\r\nimport type { SymbolCode, SymbolCodedError, SymbolCodedErrorClass, SymbolRawMessage } from \"./symbols\";\r\n\r\nexport const\r\n\t{\r\n\t\tTypeError,\r\n\t\tRangeError,\r\n\t\tReferenceError,\r\n\t\tError,\r\n\t} = makeErrors(messages, {\r\n\t\tTypeError: globalThis.TypeError,\r\n\t\tRangeError: globalThis.RangeError,\r\n\t\tReferenceError: globalThis.ReferenceError,\r\n\t\tError: globalThis.Error,\r\n\t});", "export default function formatWordList(list: string[], and = false) {\r\n\tconst last = list.pop(),\r\n\t\tlastWord = and ? \"and\" : \"or\";\r\n\r\n\tif (list.length > 1) {\r\n\t\tconst commaSeparated = list.map((s, i) => `${ i % 5 === 0 && i ? \"\\n\" : \"\" }\"${ s }\"`);\r\n\r\n\t\treturn `${ commaSeparated.join(\", \") }, ${ lastWord } \"${ last }\"`;\r\n\t} else\r\n\t\treturn `${ list.length === 1 ? `\"${ list[0] }\" ${ lastWord } ` : \"\" }\"${ last }\"`;\r\n}", "import { RangeError, ReferenceError } from \"../nativeErrors\";\r\nimport type { FormattableMessageParams,MessageFormatter, MessageKeys, MessageMap } from \"../types\";\r\nimport { MessageDescriptor } from \"../types\";\r\nimport formatWordList from \"./formatWordList\";\r\n\r\nexport default function formatErrorMessage<\r\n\tM extends MessageMap,\r\n\tCode extends MessageKeys<M>,\r\n>(messages: M, code: Code, ...formats: FormattableMessageParams<M, Code>) {\r\n\tif (!(code in messages)) throw new ReferenceError(\"INVALID_MESSAGE_CODE\", code, formatWordList(Object.keys(messages)));\r\n\r\n\tif (typeof messages[code] === \"function\" && messages[code]!.length > formats.length) throw new RangeError(\"MESSAGE_CODE_MISSING_FORMATS\", code, messages[code]!.length, formats.length);\r\n\r\n\tconst message = typeof messages[code] === \"function\"\r\n\r\n\t\t? (messages[code] as MessageFormatter)(...formats)\r\n\t\t: messages[code];\r\n\r\n\treturn message as string;\r\n}", "import { TypeError } from \"./nativeErrors\";\r\nimport { SymbolCode, SymbolCodedError, SymbolCodedErrorClass, SymbolRawMessage } from \"./symbols\";\r\n\r\nimport { ConstructorReturnType } from \"./types\";\r\nimport formatErrorMessage from \"./utils/formatErrorMessage\";\r\nimport type { FormattableMessageParams, MessageDescriptor,MessageKeys, MessageMap } from \"./types\";\r\n\r\ntype OmitCallSignature<T> =\r\n\tT extends new (...args: infer R) => infer S ? new (...args: R) => S & { [K in keyof T]: T[K] } : { [K in keyof T]: T[K] };\r\n\r\ntype OmitConstructorSignature<T> =\r\n\tT extends (...args: infer R) => infer S ? (...args: R) => S & { [K in keyof T]: T[K] } : { [K in keyof T]: T[K] };\r\ntype Map<T> = { [K in keyof T]: T[K] };\r\nexport default function makeCodedError<\r\n\tM extends MessageMap,\r\n\tT extends abstract new (...args: any[]) => Error,\r\n>(messages: M, Base: T) {\r\n\t// if (SymbolCodedErrorClass in Base) throw new TypeError(\"ERROR_CLASS_ALREADY_EXTENDED\", Base);\r\n\tif (\"$$<Symbol>codedError\" in Base) throw new TypeError(\"ERROR_CLASS_ALREADY_EXTENDED\", Base);\r\n\r\n\r\n\t// @ts-expect-error\r\n\tclass $0 <Code extends MessageKeys<M>> extends Base {\r\n\t\t// static get [SymbolCodedErrorClass]() { return true; }\r\n\t\tstatic readonly [\"$$<Symbol>codedErrorClass\"] = true;\r\n\t\tstatic [Symbol.hasInstance](instance: any) {\r\n\t\t\tconst constructor = instance[Symbol.species] || instance.constructor;\r\n\r\n\t\t\treturn instance instanceof Base || constructor === this;\r\n\t\t}\r\n\r\n\t\tstatic {\r\n\t\t\tObject.defineProperty(this, \"name\", { value: Base.name });\r\n\t\t}\r\n\r\n\t\t#message = \"\";\r\n\t\t/*\r\n\t\t * readonly [SymbolCodedError]: true;\r\n\t\t * readonly [SymbolCode]: string;\r\n\t\t * readonly [SymbolRawMessage]: string;\r\n\t\t */\r\n\t\treadonly [\"$$<Symbol>codedError\"]: true;\r\n\t\treadonly [\"$$<Symbol>code\"]: string;\r\n\t\treadonly [\"$$<Symbol>rawMessage\"]: string;\r\n\r\n\t\tconstructor(code: Code, ...formats: FormattableMessageParams<M, Code>);\r\n\t\tconstructor(code: Code, ...formats: FormattableMessageParams<M, Code>) {\r\n\t\t\tsuper(formatErrorMessage(messages, code, ...formats));\r\n\r\n\t\t\tif (typeof messages[code] !== \"string\")\r\n\t\t\t\t// this[SymbolRawMessage] = messages[code]?.toString()!;\r\n\t\t\t\tthis[\"$$<Symbol>rawMessage\"] = messages[code]?.toString()!;\r\n\r\n\t\t\tthis[\"$$<Symbol>code\"] = code.toLocaleUpperCase();\r\n\t\t\t// Object.defineProperty(this, SymbolCodedError, { value: true });\r\n\t\t\tObject.defineProperty(this, \"$$<Symbol>codedError\", { value: true });\r\n\t\t}\r\n\r\n\t\tget name() {\r\n\t\t\treturn `${ Base.name }${ this[\"$$<Symbol>code\"] ? ` [${ this[\"$$<Symbol>code\"] }]` : \"\" }`;\r\n\t\t}\r\n\r\n\t\tget message() {\r\n\t\t\treturn !this.#message ? \"\" : this.#message;\r\n\t\t}\r\n\r\n\t\tset message(value) {\r\n\t\t\tthis.#message = value;\r\n\t\t}\r\n\r\n\t\tget [Symbol.species]() { return Base; }\r\n\r\n\t\tget [Symbol.toStringTag]() {\r\n\t\t\treturn Base.name;\r\n\t\t}\r\n\t}\r\n\r\n\treturn $0 as any as (Map<typeof $0>\r\n\t\t& Omit<typeof Base, \"prototype\">\r\n\t\t& (new <Code extends MessageKeys<M>> (code: Code, ...formats: FormattableMessageParams<M, Code>) => $0<Code> & ConstructorReturnType<typeof Base>));\r\n}", "\r\nexport const\r\n\tSymbolCodedErrorClass = Symbol(\"codedErrorClass\"),\r\n\tSymbolCodedError = Symbol(\"codedError\"),\r\n\tSymbolCode = Symbol(\"code\"),\r\n\tSymbolRawMessage = Symbol(\"rawMessage\");", "import { SymbolCode } from \"../symbols\";\r\n\r\nexport default function isCodedError(errorObject: Error) {\r\n\t// return SymbolCode in errorObject;\r\n\treturn \"$$<Symbol>code\" in errorObject;\r\n}", "import { SymbolCodedErrorClass } from \"../symbols\";\r\n\r\nexport default function isCodedErrorClass(ErrorClass: typeof Error) {\r\n\t// return SymbolCodedErrorClass in ErrorClass;\r\n\treturn \"$$<Symbol>codedErrorClass\" in ErrorClass;\r\n}"],
  "mappings": "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",
  "names": []
}
